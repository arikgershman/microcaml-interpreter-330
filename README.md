# MicroCaml Lexer, Parser, and Interpreter ðŸ§©

This repository contains my implementation for Project 4, a MicroCaml Lexer, Parser, and Interpreter, from my CMSC330: Organization of Programming Languages at UMD. This project involved building a dynamically-typed version of OCaml from the ground up, including lexical analysis, parsing into an Abstract Syntax Tree (AST), and evaluating the AST.

The core objective was to understand and implement the fundamental components of a programming language, providing practical experience with compiler design principles in a functional programming context.

## Project Overview

This project is divided into two main parts:

### Part A: Lexer & Parser

In this part, I implemented the lexical analyzer (lexer) and parser for MicroCaml.

* **Lexer (`lexer.ml`)**:
    * **`tokenize: string -> token list`**: Converts an input MicroCaml string into a sequence of tokens. This involved handling various token types (integers, booleans, strings, identifiers, operators, keywords), whitespace, and applying rules like longest match and specific negative integer parsing.
* **Parser (`parser.ml`)**:
    * **`parse_expr: token list -> token list * expr`**: Consumes a list of tokens to produce an AST representing a MicroCaml expression (`expr` type). This involved implementing a recursive descent parser based on the provided MicroCaml grammar, handling operator precedence and associativity.
    * **`parse_mutop: token list -> token list * mutop`**: Parses top-level MicroCaml directives (`mutop` type), such as variable definitions (`def`) or expressions, which always terminate with `;;`. This function reuses the `parse_expr` implementation.

### Part B: Interpreter

In this part, I implemented the interpreter to execute the ASTs generated by the parser.

* **Evaluator (`eval.ml`)**:
    * **`eval_expr: environment -> expr -> expr`**: Evaluates a MicroCaml expression within a given environment. This function handles all expression types, including arithmetic, logical, and relational operations, conditionals (`if-then-else`), function application (`App`), anonymous functions (`Fun`), `let` bindings (both recursive and non-recursive), records, and field selection. It also implements dynamic type checking and raises specific exceptions for errors (e.g., `TypeError`, `DivByZeroError`).
    * **`eval_mutop: environment -> mutop -> environment * (expr option)`**: Evaluates top-level MicroCaml directives, updating the environment and returning any resulting expression. This includes handling `def` for global, implicitly recursive definitions, and executing standalone expressions.

## Key Concepts & Challenges

* **Lexical Analysis:** Implementing a tokenizer to convert raw input into a structured token stream, handling complex regex patterns and longest-match rules.
* **Parsing (Context-Free Grammars & ASTs):** Designing and implementing a recursive descent parser to transform a token stream into a hierarchical Abstract Syntax Tree, correctly reflecting operator precedence and associativity.
* **Interpreter Design:** Building an interpreter that traverses the AST, evaluates expressions, manages execution environments (including lexical scoping and recursive bindings), and performs runtime type checking.
* **Functional Programming with Imperative Elements:** While primarily functional, the project required strategic use of OCaml's imperative features (specifically `ref` for environment updates) to correctly implement recursive `let` and `def` bindings.
* **Error Handling:** Implementing robust error handling for various runtime scenarios, including type mismatches, division by zero, and undefined variables.

## Repository Structure

* `src/lexer.ml`: Contains the `tokenize` function.
* `src/parser.ml`: Contains the `parse_expr` and `parse_mutop` functions.
* `src/eval.ml`: Contains the `eval_expr` and `eval_mutop` functions.
* `src/types.ml`: (Provided) Defines the `token`, `expr`, `mutop`, and `environment` types, along with custom exceptions.
* `src/utils.ml`: (Provided) Utility functions for parsing.
* `test/`: Contains testing infrastructure (public and student tests).
* `bin/mutop.exe`: The executable for the MicroCaml top-level interpreter.

## How to Run / Test the Project

To run and test this OCaml project, ensure you have OCaml installed. The project uses `dune` as its build system.

1.  **Build the Project:**
    Compile your code:
    ```bash
    dune build
    ```

2.  **Run All Tests (Public and Student):**
    Execute all available tests:
    ```bash
    dune runtest -f
    ```

3.  **Run Specific Test File (e.g., public tests):**
    To run tests from a particular file:
    ```bash
    dune runtest -f test/public
    ```

    (Replace `test/public` with the path to your desired test file.)

4.  **Interactive Testing with Utop:**
    For an interactive OCaml top-level environment with your project functions loaded:
    ```bash
    dune utop src
    ```

    In `utop`, all commands must end with `;;`. Exit `utop` by typing `#quit;;` or pressing `Ctrl-D` / `Cmd-D`.

5.  **Run the MicroCaml `mutop` Interpreter:**
    Using my working lexer, parser, and evaluator, you can interact with the MicroCaml interpreter:
    ```bash
    dune exec bin/mutop.exe
    ```
    
    This will open a `mutop #` prompt where you can type MicroCaml expressions and definitions, ending each with `;;`. **To exit the `mutop` interpreter, press `Ctrl-D` / `Cmd-D`.**
